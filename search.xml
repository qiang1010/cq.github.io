<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>next 主题使用</title>
    <url>/2020/05/25/next%20%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>官网： <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a><br>
HEXO: <a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands</a></p>
<h2 id="init">init</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure>
<p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p>
<h2 id="new">new</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure>
<p>参数  描述<br>
-p, --path	自定义新文章的路径<br>
-r, --replace	如果存在同名文章，将其替换<br>
-s, --slug	文章的 Slug，作为新文章的文件名和发布后的 URL<br>
默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <a href="http://index.md" target="_blank" rel="noopener">index.md</a> 文件。你可以使用 --path 参数来覆盖上述行为、自行决定文件的目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me &quot;About me&quot;</span><br></pre></td></tr></table></figure>
<p>以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 “About me”</p>
<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me</span><br></pre></td></tr></table></figure>
<p>此时 Hexo 会创建 source/_posts/about/me.md，同时 <a href="http://me.md" target="_blank" rel="noopener">me.md</a> 的 Front Matter 中的 title 为 “page”。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。</p>
<h2 id="generate">generate</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>生成静态文件。<br>
选项	描述<br>
-d, --deploy	文件生成后立即部署网站<br>
-w, --watch	监视文件变动<br>
-b, --bail	生成过程中如果发生任何未处理的异常则抛出异常<br>
-f, --force	强制重新生成文件<br>
Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。<br>
使用该参数的效果接近 hexo clean &amp;&amp; hexo generate<br>
-c, --concurrency	最大同时生成文件的数量，默认无限制<br>
该命令可以简写为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<h2 id="publish">publish</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>发表草稿。</p>
<h2 id="server">server</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82" target="_blank" rel="noopener">http://localhost:4000/。</a></p>
<p>选项	描述<br>
-p, --port	重设端口<br>
-s, --static	只使用静态文件<br>
-l, --log	启动日记记录，使用覆盖记录格式</p>
<h2 id="deploy">deploy</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>部署网站。</p>
<p>参数	描述<br>
-g, --generate	部署之前预先生成静态文件</p>
<p>该命令可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo  &amp;&amp; Next 主题</category>
      </categories>
  </entry>
  <entry>
    <title>vue知识点</title>
    <url>/2020/05/25/vue/vue%E8%80%83%E7%82%B9/</url>
    <content><![CDATA[<h1>vue  通信方式</h1>
]]></content>
  </entry>
  <entry>
    <title>手写Promise</title>
    <url>/2020/05/26/promise/%E6%89%8B%E5%86%99Promise/</url>
    <content><![CDATA[<h1>手写 Promise</h1>
<p>参考链接：<a href="https://juejin.im/post/5b2f02cd5188252b937548ab" target="_blank" rel="noopener">https://juejin.im/post/5b2f02cd5188252b937548ab</a><br>
珠峰公开课，姜文老师，讲了一遍手写 Promise，略懂一二。</p>
<p>手写Promise 必须熟悉 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">promisesA+规范</a><br>
具体细节可参考 链接，讲的很详细，<br>
直接上代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const RESOLVED &#x3D; &#39;RESOLVE&#39;;</span><br><span class="line">const REJECTD &#x3D; &#39;REJECTD&#39;;</span><br><span class="line">const PENDING &#x3D; &#39;PENDING&#39;;</span><br><span class="line">const isFunction &#x3D; fn &#x3D;&gt; (typeof fn &#x3D;&#x3D;&#x3D; &#39;function&#39;);</span><br><span class="line">const isObject &#x3D; obj &#x3D;&gt; (obj !&#x3D;&#x3D; null &amp;&amp; typeof obj &#x3D;&#x3D;&#x3D; &#39;object&#39;);</span><br><span class="line">&#x2F;&#x2F; resolvePromise函数</span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">    &#x2F;&#x2F; 循环引用报错</span><br><span class="line">    if (x &#x3D;&#x3D;&#x3D; promise2) &#123;</span><br><span class="line">        &#x2F;&#x2F; reject报错</span><br><span class="line">        return reject(new TypeError(&#39;Chaining cycle detected for promise&#39;));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 防止多次调用</span><br><span class="line">    let called;</span><br><span class="line">    &#x2F;&#x2F; x不是null 且x是对象或者函数</span><br><span class="line">    if (isObject(x) || isFunction(x)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 声明x 的then 方法</span><br><span class="line">            let xthen &#x3D; x.then;</span><br><span class="line">            if (isFunction(xthen)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 就让xthen执行 第一个参数是this   后面是成功的回调 和 失败的回调</span><br><span class="line">                xthen.call(x, y &#x3D;&gt; &#123;</span><br><span class="line">                    if (called) return;</span><br><span class="line">                    called &#x3D; true;</span><br><span class="line">                    console.log(&#39;函数对象y&#39;, y)</span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, err &#x3D;&gt; &#123;</span><br><span class="line">                    if (called) return;</span><br><span class="line">                    called &#x3D; true;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 非函数对象</span><br><span class="line">                console.log(&#39;非函数的对象&#39;, x);</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">            if (called) return;</span><br><span class="line">            called &#x3D; true;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#39;非对象&#39;, x);</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class PromiseA &#123;</span><br><span class="line">    constructor(executor) &#123;</span><br><span class="line">        this.status &#x3D; PENDING;</span><br><span class="line">        this.value &#x3D; &#39;&#39;;</span><br><span class="line">        this.reason &#x3D; &#39;&#39;;</span><br><span class="line">        &#x2F;&#x2F; 成功存放的数组</span><br><span class="line">        this.onResolvedCallbacks &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F; 失败存放的数组</span><br><span class="line">        this.onRejectedCallbacks &#x3D; [];</span><br><span class="line">        let resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">                this.status &#x3D; RESOLVED;</span><br><span class="line">                &#x2F;&#x2F; 一旦resolve执行，调用成功数组的函数</span><br><span class="line">                this.onResolvedCallbacks.forEach(fn &#x3D;&gt; fn())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">                this.status &#x3D; REJECTD;</span><br><span class="line">                &#x2F;&#x2F; 一旦reject执行，调用失败数组的函数</span><br><span class="line">                this.onRejectedCallbacks.forEach(fn &#x3D;&gt; fn())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.log(error);</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; then 方法 有两个参数onFulfilled onRejected</span><br><span class="line">    &#x2F;&#x2F; 成功会把value  传入 onFulfilled； 失败会把reason 传入 onRejected</span><br><span class="line">    then(onFullfilled, onRejected) &#123;</span><br><span class="line">        console.log(this.status, &#39;then&#39;);</span><br><span class="line">        &#x2F;&#x2F; onFulfilled如果不是函数，就忽略onFulfilled，直接返回value</span><br><span class="line">        onFullfilled &#x3D; typeof onFullfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFullfilled : value &#x3D;&gt; value;</span><br><span class="line">        &#x2F;&#x2F; onRejected如果不是函数，就忽略onRejected，直接扔出错误</span><br><span class="line">        onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onRejected : err &#x3D;&gt; &#123; throw err &#125;;</span><br><span class="line">        &#x2F;&#x2F; 兼容链式调用，用来解决回调地狱 返回一个新的promise</span><br><span class="line">        let promise2 &#x3D; new PromiseA((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; RESOLVED) &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x &#x3D; onFullfilled(this.value)</span><br><span class="line">                        &#x2F;&#x2F; 这个地方promise2 需要异步 不然会报错</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; catch (error) &#123;</span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; REJECTD) &#123;</span><br><span class="line">                console.log(this.status, this.value);</span><br><span class="line">                let x &#x3D; onRejected(this.reason)</span><br><span class="line">                resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 解决异步问题，但是当resolve在setTomeout内执行，then时state还是pending等待状态 </span><br><span class="line">            &#x2F;&#x2F; 我们就需要在then调用的时候，将成功和失败存到各自的数组，一旦reject或者resolve，就调用它们</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">                &#x2F;&#x2F; 用数组存起来</span><br><span class="line">                this.onResolvedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                    let x &#x3D; onFullfilled(this.value)</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125;)</span><br><span class="line">                this.onRejectedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">                    let x &#x3D; onRejected(this.reason)</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        return promise2;</span><br><span class="line">    &#125;</span><br><span class="line">    finally(callback) &#123;</span><br><span class="line">        return this.then((value) &#x3D;&gt; &#123;</span><br><span class="line">            return PromiseA.resolve(callback()).then(() &#x3D;&gt; value);</span><br><span class="line">        &#125;, (reason) &#x3D;&gt; &#123;</span><br><span class="line">            return PromiseA.esolve(callback()).then(() &#x3D;&gt; &#123; throw reason &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    catch(errcallback) &#123;</span><br><span class="line">        return this.then(null, errcallback);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;resolve方法</span><br><span class="line">    static resolve(val) &#123;</span><br><span class="line">        console.log(val);</span><br><span class="line">        return new PromiseA((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            resolve(val)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;reject方法</span><br><span class="line">    static reject(val) &#123;</span><br><span class="line">        return new PromiseA((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            reject(val)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;race方法 </span><br><span class="line">    static race(promises) &#123;</span><br><span class="line">        return new PromiseA((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            for (let i &#x3D; 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">                promises[i].then(resolve, reject)</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; all方法(获取所有的promise，都执行then，把结果放到数组，一起返回)</span><br><span class="line">    static all(promises) &#123;</span><br><span class="line">        let arr &#x3D; [];</span><br><span class="line">        let i &#x3D; 0;</span><br><span class="line">        function processData(index, data) &#123;</span><br><span class="line">            arr[index] &#x3D; data;</span><br><span class="line">            i++;</span><br><span class="line">            if (i &#x3D;&#x3D; promises.length) &#123;</span><br><span class="line">                resolve(arr);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        return new PromiseA((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">            for (let i &#x3D; 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">                promises[i].then(data &#x3D;&gt; &#123;</span><br><span class="line">                    processData(i, data);</span><br><span class="line">                &#125;, reject);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 测试代码</span><br><span class="line">let promise &#x3D; new PromiseA((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;成功&#39;);</span><br><span class="line">    return new PromiseA((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#39;nihaoahah&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(null, (e) &#x3D;&gt; &#123;</span><br><span class="line">    return new PromiseA((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        resolve(&#39;nihaoahah&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">PromiseA.resolve(344343).then((data) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;);</span><br><span class="line">PromiseA.resolve(344343).finally(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;23332&#39;)</span><br><span class="line">    return new PromiseA((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            resolve(&#39;ok&#39;)</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then((d) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(d, &#39;ssss&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">    .catch(e &#x3D;&gt; &#123;</span><br><span class="line">        console.log(e, &#39;ddd&#39;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
</search>
