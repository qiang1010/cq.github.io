<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>next 主题使用</title>
    <url>/2020/05/25/next%20%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>官网： <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a><br>
HEXO: <a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands</a></p>
<h2 id="init">init</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure>
<p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p>
<h2 id="new">new</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure>
<p>参数  描述<br>
-p, --path	自定义新文章的路径<br>
-r, --replace	如果存在同名文章，将其替换<br>
-s, --slug	文章的 Slug，作为新文章的文件名和发布后的 URL<br>
默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <a href="http://index.md" target="_blank" rel="noopener">index.md</a> 文件。你可以使用 --path 参数来覆盖上述行为、自行决定文件的目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me &quot;About me&quot;</span><br></pre></td></tr></table></figure>
<p>以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 “About me”</p>
<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me</span><br></pre></td></tr></table></figure>
<p>此时 Hexo 会创建 source/_posts/about/me.md，同时 <a href="http://me.md" target="_blank" rel="noopener">me.md</a> 的 Front Matter 中的 title 为 “page”。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。</p>
<h2 id="generate">generate</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>生成静态文件。<br>
选项	描述<br>
-d, --deploy	文件生成后立即部署网站<br>
-w, --watch	监视文件变动<br>
-b, --bail	生成过程中如果发生任何未处理的异常则抛出异常<br>
-f, --force	强制重新生成文件<br>
Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。<br>
使用该参数的效果接近 hexo clean &amp;&amp; hexo generate<br>
-c, --concurrency	最大同时生成文件的数量，默认无限制<br>
该命令可以简写为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<h2 id="publish">publish</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>发表草稿。</p>
<h2 id="server">server</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82" target="_blank" rel="noopener">http://localhost:4000/。</a></p>
<p>选项	描述<br>
-p, --port	重设端口<br>
-s, --static	只使用静态文件<br>
-l, --log	启动日记记录，使用覆盖记录格式</p>
<h2 id="deploy">deploy</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>部署网站。</p>
<p>参数	描述<br>
-g, --generate	部署之前预先生成静态文件</p>
<p>该命令可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo  &amp;&amp; Next 主题</category>
      </categories>
  </entry>
  <entry>
    <title>手写Promise</title>
    <url>/2020/05/26/promise/%E6%89%8B%E5%86%99Promise/</url>
    <content><![CDATA[<h1>手写 Promise</h1>
<p>参考链接：<a href="https://juejin.im/post/5b2f02cd5188252b937548ab" target="_blank" rel="noopener">https://juejin.im/post/5b2f02cd5188252b937548ab</a><br>
珠峰公开课，姜文老师，讲了一遍手写 Promise，略懂一二。</p>
<p>手写Promise 必须熟悉 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">promisesA+规范</a><br>
具体细节可参考 链接，讲的很详细，<br>
直接上代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'RESOLVE'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTD = <span class="string">'REJECTD'</span>;</span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span>;</span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">fn</span> =&gt;</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>);</span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function"><span class="params">obj</span> =&gt;</span> (obj !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span>);</span><br><span class="line"><span class="comment">// resolvePromise函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 循环引用报错</span></span><br><span class="line">    <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">        <span class="comment">// reject报错</span></span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Chaining cycle detected for promise'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止多次调用</span></span><br><span class="line">    <span class="keyword">let</span> called;</span><br><span class="line">    <span class="comment">// x不是null 且x是对象或者函数</span></span><br><span class="line">    <span class="keyword">if</span> (isObject(x) || isFunction(x)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 声明x 的then 方法</span></span><br><span class="line">            <span class="keyword">let</span> xthen = x.then;</span><br><span class="line">            <span class="keyword">if</span> (isFunction(xthen)) &#123;</span><br><span class="line">                <span class="comment">// 就让xthen执行 第一个参数是this   后面是成功的回调 和 失败的回调</span></span><br><span class="line">                xthen.call(x, y =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">'函数对象y'</span>, y)</span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, err =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 非函数对象</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'非函数的对象'</span>, x);</span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'非对象'</span>, x);</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PromiseA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = PENDING;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = <span class="string">''</span>;</span><br><span class="line">        <span class="comment">// 成功存放的数组</span></span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks = [];</span><br><span class="line">        <span class="comment">// 失败存放的数组</span></span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line">        <span class="keyword">let</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="keyword">this</span>.status = RESOLVED;</span><br><span class="line">                <span class="comment">// 一旦resolve执行，调用成功数组的函数</span></span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.reason = reason;</span><br><span class="line">                <span class="keyword">this</span>.status = REJECTD;</span><br><span class="line">                <span class="comment">// 一旦reject执行，调用失败数组的函数</span></span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// then 方法 有两个参数onFulfilled onRejected</span></span><br><span class="line">    <span class="comment">// 成功会把value  传入 onFulfilled； 失败会把reason 传入 onRejected</span></span><br><span class="line">    then(onFullfilled, onRejected) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.status, <span class="string">'then'</span>);</span><br><span class="line">        <span class="comment">// onFulfilled如果不是函数，就忽略onFulfilled，直接返回value</span></span><br><span class="line">        onFullfilled = <span class="keyword">typeof</span> onFullfilled === <span class="string">'function'</span> ? onFullfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">        <span class="comment">// onRejected如果不是函数，就忽略onRejected，直接扔出错误</span></span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="keyword">throw</span> err &#125;;</span><br><span class="line">        <span class="comment">// 兼容链式调用，用来解决回调地狱 返回一个新的promise</span></span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === RESOLVED) &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFullfilled(<span class="keyword">this</span>.value)</span><br><span class="line">                        <span class="comment">// 这个地方promise2 需要异步 不然会报错</span></span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                        reject(error);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTD) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.status, <span class="keyword">this</span>.value);</span><br><span class="line">                <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">                resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解决异步问题，但是当resolve在setTomeout内执行，then时state还是pending等待状态 </span></span><br><span class="line">            <span class="comment">// 我们就需要在then调用的时候，将成功和失败存到各自的数组，一旦reject或者resolve，就调用它们</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">                <span class="comment">// 用数组存起来</span></span><br><span class="line">                <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onFullfilled(<span class="keyword">this</span>.value)</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>(callback) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> PromiseA.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value);</span><br><span class="line">        &#125;, (reason) =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> PromiseA.esolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span>(errcallback) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, errcallback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//resolve方法</span></span><br><span class="line">    <span class="keyword">static</span> resolve(val) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve(val)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//reject方法</span></span><br><span class="line">    <span class="keyword">static</span> reject(val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            reject(val)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//race方法 </span></span><br><span class="line">    <span class="keyword">static</span> race(promises) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">                promises[i].then(resolve, reject)</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// all方法(获取所有的promise，都执行then，把结果放到数组，一起返回)</span></span><br><span class="line">    <span class="keyword">static</span> all(promises) &#123;</span><br><span class="line">        <span class="keyword">let</span> arr = [];</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">processData</span>(<span class="params">index, data</span>) </span>&#123;</span><br><span class="line">            arr[index] = data;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == promises.length) &#123;</span><br><span class="line">                resolve(arr);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">                promises[i].then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                    processData(i, data);</span><br><span class="line">                &#125;, reject);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'成功'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'nihaoahah'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="literal">null</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="string">'nihaoahah'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">PromiseA.resolve(<span class="number">344343</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;);</span><br><span class="line">PromiseA.resolve(<span class="number">344343</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'23332'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseA(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'ok'</span>)</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">d</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(d, <span class="string">'ssss'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e, <span class="string">'ddd'</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>动手学习Promise</title>
    <url>/2020/05/27/promise/%E9%80%9A%E8%BF%87%E4%BB%A3%E7%A0%81%E7%BB%83%E4%B9%A0%E6%8E%8C%E6%8F%A1Promise/</url>
    <content><![CDATA[<h1>通过代码练习掌握Promise</h1>
<h2 id="Promise的立即执行性">Promise的立即执行性</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> P0 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"create"</span>);</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"next"</span>);</span><br><span class="line">P0.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">create</span><br><span class="line">next</span><br><span class="line">success</span><br></pre></td></tr></table></figure>
<p>创建new Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。</p>
<h2 id="Promise-三种状态-pending，resolved，rejected">Promise 三种状态 pending，resolved，rejected</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);  </span><br><span class="line">  &#125;, <span class="number">500</span>);      </span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    reject(<span class="number">3</span>);  </span><br><span class="line">  &#125;, <span class="number">500</span>);      </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"><span class="built_in">console</span>.log(p2);</span><br><span class="line"><span class="built_in">console</span>.log(p3);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p2);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p3);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line">p3.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise &#123; resolved &#125;</span><br><span class="line">Promise &#123; pending &#125;</span><br><span class="line">Promise &#123; pending &#125;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Promise &#123; resolved &#125;</span><br><span class="line">Promise &#123; rejected &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Promise-状态的不可逆性">Promise 状态的不可逆性</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">"success1"</span>);</span><br><span class="line">    resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p5 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">    reject(<span class="string">"reject"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p5.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">success1</span><br><span class="line">success</span><br></pre></td></tr></table></figure>
<p>Promise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。</p>
<h2 id="链式调用">链式调用</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;               <span class="comment">//第一个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value*<span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第二个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第三个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>); </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第四个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第五个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>+ value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span> + err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="string">"resolve"</span></span><br><span class="line"><span class="string">"reject: reject"</span></span><br></pre></td></tr></table></figure>
<p>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：</p>
<ul>
<li>return 一个同步的值 ，或者 undefined（当没有返回一个有效值时，默认返回undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。</li>
<li>return 另一个 Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。</li>
<li>throw 一个同步异常，then方法将返回一个rejected状态的Promise,  值是该异常。</li>
</ul>
<p>根据以上分析，代码中第一个then会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个then输出的值是2。第二个then中没有返回值，因此将返回默认的undefined，于是在第三个then中输出undefined。第三个then和第四个then中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个then中成功的回调函数和第五个then中失败的回调函数处理。</p>
<h2 id="Promise-then-回调异步性">Promise then() 回调异步性</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>复制代码控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>复制代码Promise接收的函数参数是同步执行的，但then方法中的回调函数执行则是异步的，因此，&quot;success&quot;会在后面输出。</p>
<hr>
<h2 id="Promise-中的异常">Promise 中的异常</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  foo.bar();</span><br><span class="line">  resolve( <span class="number">1</span> );	  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then value: '</span>+value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve( <span class="number">2</span> );	</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then value: '</span> + value);</span><br><span class="line">    foo.bar();</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then err: '</span> + err);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p1 then err: ReferenceError: foo is not defined</span><br><span class="line">p2 then value: 2</span><br><span class="line">p1 then then value: undefined</span><br><span class="line">p2 then then err: ReferenceError: foo is not defined</span><br><span class="line">p2 then then then value: 1</span><br></pre></td></tr></table></figure>
<p>复制代码Promise中的异常由then参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，then返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级then的回调函数是交替执行的 ，这正是由Promise then回调的异步性决定的。</p>
<hr>
<h2 id="Promise-resolve">Promise.resolve()</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( p1 );</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2); </span><br><span class="line"><span class="built_in">console</span>.log(p1 === p3);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p4);</span><br><span class="line"><span class="built_in">console</span>.log(p3 === p4);</span><br><span class="line"></span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p4='</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2='</span> + value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1='</span> + value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">false</span><br><span class="line">p2&#x3D;1</span><br><span class="line">p1&#x3D;1</span><br><span class="line">p4&#x3D;1</span><br></pre></td></tr></table></figure>
<p>复制代码Promise.resolve(…)可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的then最先调用，但在控制台上是最后输出结果的呢？因为p4的resolve中接收的参数是一个Promise对象p1，resolve会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。</p>
<h2 id="resolve-vs-reject">resolve vs reject</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p1 &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">  resolve(Promise.resolve(&#39;resolve&#39;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var p2 &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">  resolve(Promise.reject(&#39;reject&#39;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var p3 &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">  reject(Promise.resolve(&#39;resolve&#39;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">  function fulfilled(value)&#123;</span><br><span class="line">    console.log(&#39;fulfilled: &#39; + value);</span><br><span class="line">  &#125;, </span><br><span class="line">  function rejected(err)&#123;</span><br><span class="line">    console.log(&#39;rejected: &#39; + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">  function fulfilled(value)&#123;</span><br><span class="line">    console.log(&#39;fulfilled: &#39; + value);</span><br><span class="line">  &#125;, </span><br><span class="line">  function rejected(err)&#123;</span><br><span class="line">    console.log(&#39;rejected: &#39; + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p3.then(</span><br><span class="line">  function fulfilled(value)&#123;</span><br><span class="line">    console.log(&#39;fulfilled: &#39; + value);</span><br><span class="line">  &#125;, </span><br><span class="line">  function rejected(err)&#123;</span><br><span class="line">    console.log(&#39;rejected: &#39; + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p3 rejected: [object Promise]</span><br><span class="line">p1 fulfilled: resolve</span><br><span class="line">p2 rejected: reject</span><br></pre></td></tr></table></figure>
<p>复制代码Promise回调函数中的第一个参数resolve，会对Promise执行&quot;拆箱&quot;动作。即当resolve的参数是一个Promise对象时，resolve会&quot;拆箱&quot;获取这个Promise对象的状态和值，但这个过程是异步的。p1&quot;拆箱&quot;后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；p2&quot;拆箱&quot;后，获取到Promise对象的状态是rejected，因此rejected回调被执行。但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。</p>
<hr>
<p>参考链接：<a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="noopener">https://juejin.im/post/597724c26fb9a06bb75260e8</a></p>
]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>复习Vue 基础知识点</title>
    <url>/2020/05/27/vue/vue%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1>复习Vue 基础知识点</h1>
<h2 id="参考链接">参考链接</h2>
<ul>
<li>慕课教程 <a href="http://www.imooc.com/wiki/vuelesson" target="_blank" rel="noopener">http://www.imooc.com/wiki/vuelesson</a></li>
<li>Vue官网 <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></li>
</ul>
<h2 id="Vue基础">Vue基础</h2>
<h3 id="常用指令">常用指令</h3>
<ul>
<li>v-if: DOM 生成或移除</li>
<li>v-show: HTML 元素显示或隐藏</li>
<li>v-else: 在v-if或v-show 后使用</li>
<li>v-model: 用在表单元素上的双向数据绑定。 附加参数：number：输入转为Number类型》、 lazy：将数据改到change 事件、debounce：提交防抖，.trim 去空格</li>
<li>v-for: 循环渲染数据，配合过滤器使用，filterBy 、orderBy</li>
<li>v-text:  元素内容</li>
<li>v-html: 更新innerHtml</li>
<li>v-bind: 设置属性, 属性名=[变量名]。例如:v-bind:title=“xx”：</li>
<li>v-on: 事件监听器v-on:事件名=“方法”，例如：v-on：click=“alert”。</li>
<li>v-pre:  该指令会跳过所在元素和它的子元素的编译过程，也就是把这个节点及其子节点当作一个静态节点来处理，</li>
<li>v-once: 模板只会在第一次更新时显示数据，此后再次更新该DOM里面引用的数据时，内容不会自动更新。</li>
</ul>
<h3 id="v-bind动态绑定样式">v-bind动态绑定样式</h3>
<ul>
<li>通过 v-bind:class 动态绑定元素的 Class；</li>
<li>v-bind:style 动态绑定元素的内联样式；</li>
<li>如果通过数组和对象的形式给 v-bind:class 和 v-bind:style 赋值。</li>
</ul>
<h3 id="计算属性-computed">计算属性 computed</h3>
<p>官方定义：计算属性就是当其依赖属性的值发生变化时,这个属性的值会自动更新,与之相关的DOM部分也会同步自动更新。</p>
<ul>
<li>通过计算属性 computed 来代替在模板编写复杂逻辑的使用方法。</li>
<li>利用 setter 和 getter 来编写一个复杂的计算属性。</li>
</ul>
<h4 id="computed-vs-methods">computed vs methods</h4>
<ul>
<li>计算属性：基于它们的响应式依赖进行缓存的</li>
<li>方法：每次都会重新执行。</li>
</ul>
<h4 id="watch-侦听器">watch  侦听器</h4>
<p>侦听属性: Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。 — 官方定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    count: <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 具体处理逻辑</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p>
<ul>
<li>通过侦听器来监听数据的变化，进行相应的逻辑处理。</li>
<li>如何监听对象类型数据的某个属性进行侦听。</li>
<li>侦听器的高级用法，handler 函数、立即触发 immediate 属性、深度监听 deep 属性。</li>
</ul>
<h3 id="事件处理">事件处理</h3>
<p>可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。 — 官方定义</p>
<p>基本使用： 事件监听，事件函数，参数传递，原生DOM获取</p>
<h4 id="事件修饰符">事件修饰符</h4>
<p>event.preventDefault() 用来取消事件的默认动作。<br>
event.stopPropagation() 用来阻止事件冒泡到父元素，阻止任何父事件处理程序被执行。</p>
<p>Vue 提供了以下事件修饰符：</p>
<ul>
<li>.stop: 阻止单击事件继续传播；</li>
<li>.prevent: 只有修饰符，提交事件不再重载页面。</li>
<li>.capture: 添加事件监听器时使用事件捕获模式，即元素自身触发的事件先在自身处理，然后交由内部元素进行处理；</li>
<li>.self: 只有在event.target是当前元素自身时触发处理函数，即事件不是从内部元素触发的；</li>
<li>.once: 点击事件将只触发一次</li>
<li>.passive: 滚动事件会立即触发，不会等待其他串联事件。即prevent会失效。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop=<span class="string">"doThis"</span>&gt;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent=<span class="string">"doThat"</span>&gt;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;div v-on:click.capture="doThis"&gt;...&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="line">&lt;div v-on:click.self=<span class="string">"doThat"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;a v-on:click.once="doThis"&gt;&lt;/</span>a&gt;</span><br></pre></td></tr></table></figure>
<h4 id="按键修饰符">按键修饰符</h4>
<ul>
<li>.enter: 回车键；</li>
<li>.tab: TAB键；</li>
<li>.delete: 删除和退格键；</li>
<li>.esc: 只有在event.终止键；</li>
<li>.space: 删除键；</li>
<li>.up: 上方向键：</li>
<li>.down: 下方向键：</li>
<li>.left: 左方向键：</li>
<li>.right: 右方向键：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 只有在 <span class="string">`key`</span> 是 <span class="string">`Enter`</span> 时调用 <span class="string">`login()`</span> --&gt;</span><br><span class="line">&lt;input v-on:keyup.enter=<span class="string">"login"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 也可以使用 keyCode --&gt;</span><br><span class="line">&lt;input v-on:keyup<span class="number">.13</span>=<span class="string">"login"</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="系统修饰符">系统修饰符</h4>
<ul>
<li>.ctrl:</li>
<li>.alt:</li>
<li>.shift:</li>
<li>.meta:</li>
</ul>
<h3 id="生命周期">生命周期</h3>
<p><img src="/2020/05/27/vue/vue%E5%9F%BA%E7%A1%80/vue.jpg" alt="生命周期"></p>
<ul>
<li>
<p>beforeCreate（创建前）:在实例初始化之后，此时的数据观察和事件机制都未形成，不能获得 DOM节点。</p>
</li>
<li>
<p>created（创建后）:实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测（data observer），属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始。</p>
</li>
<li>
<p>beforeMount(载入前):在挂载开始之前被调用：这个过程是在模版已经在内存中编译完成， render 函数首次被调用，此时完成了虚拟 DOM 的构建，但并未被渲染。</p>
</li>
<li>
<p>mounted（载入后）:这个过程在模版挂载之后被调用，页面完成渲染，在这之后所以我们可以操作和访问 DOM 元素。</p>
</li>
<li>
<p>beforeUpdate（更新前）:当数据更新时调用，在这一阶段 DOM 会和更改过的内容同步。</p>
</li>
<li>
<p>updated（更新后）:由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<br>
当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</p>
</li>
<li>
<p>beforeDestroy（销毁前）:实例销毁之前调用。在这一步，实例仍然完全可用。</p>
</li>
<li>
<p>destroyed（销毁后）:Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
</li>
</ul>
<h3 id="插槽">插槽</h3>
<p><slot>有三种类型，他们分别是：</slot></p>
<ul>
<li>默认插槽 default</li>
<li>具名插槽 name</li>
<li>作用域插槽 v-slot</li>
</ul>
<h3 id="Vue-组件间通信">Vue 组件间通信</h3>
<ul>
<li>父组件通过 props 传递数据给子组件：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在子组件内定义组件接收一个参数 name</span></span><br><span class="line">&#123;</span><br><span class="line">  props: [<span class="string">'name'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件使用组件时传递参数 name</span></span><br><span class="line">&lt;child :name=<span class="string">"name"</span>&gt;&lt;<span class="regexp">/child&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子组件通过 $emit 传递数据给父组件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件定义事件</span></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'事件名称'</span>, <span class="string">'传递的参数'</span>) <span class="comment">//例： this.$emit('add', 111)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父组件监听事件的触发</span></span><br><span class="line">&lt;child  @事件名称=<span class="string">"事件触发的方法"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://juejin.im/post/5c77c4ae518825407505e262#heading-8" target="_blank" rel="noopener">https://juejin.im/post/5c77c4ae518825407505e262#heading-8</a></p>
<h3 id="动态组件">动态组件</h3>
<p>使用 <code>&lt;component :is=&quot;component-name&quot;/&gt;</code> 的方式实现动态组件；</p>
<h3 id="keep-alive">keep-alive</h3>
<p>keep-alive 是 Vue 提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在页面渲染完毕后不会被渲染成一个 DOM 元素。被 keep-alive 缓存的组件只有在初次渲染时才会被创建，并且当组件切换时不会被销毁。</p>
<h4 id="activated-和-deactivated-生命周期">activated 和 deactivated 生命周期</h4>
<p>activated 和 deactivated 和我们之学习的生命周期函数一样，也是组件的生命周期函数。不过， activated 和 deactivated 只在 <keep-alive> 内的所有嵌套组件中触发。activated：进入组件时触发。deactivated：退出组件时触发。</keep-alive></p>
<h4 id="include-和-exclude">include 和 exclude</h4>
<p>include 和 exclude 是 keep-alive 的两个属性，允许组件有条件地缓存。<br>
include： 可以是字符串或正则表达式，用来表示只有名称匹配的组件会被缓存<br>
exclude： 可以是字符串或正则表达式，用来表示名称匹配的组件不会被缓存</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
